# Implementation Plan: App Stability & Responsiveness Hardening

**Branch**: `001-app-stability` | **Date**: 2026-01-30 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-app-stability/spec.md`

## Summary

Harden PodcastAnalyzer for responsiveness, memory stability, error recovery, and observability across iOS and macOS. No architectural rewrite — targeted fixes to retain cycles, main-thread violations, observer lifecycles, error handling gaps, low-memory handling, and crash reporting. Organized in three phases: quick wins, deeper refactoring, and observability + test harness.

## Technical Context

**Language/Version**: Swift 6 / Xcode 16+
**Primary Dependencies**: SwiftUI, SwiftData, AVFoundation, FeedKit, ZMarkupParser (no new deps)
**Storage**: SwiftData (local-first), UserDefaults, file system
**Testing**: XCTest (unit + UI stress tests)
**Target Platform**: iOS 26.0+, macOS 26.0+
**Project Type**: Mobile (dual-platform SwiftUI app)
**Performance Goals**: <200ms UI response, 45+ fps scroll, <150 MB idle memory, <300 MB peak
**Constraints**: <16ms view body eval, zero main-thread blocks >16ms, zero retain cycles
**Scale/Scope**: ~83 Swift files, 32K LOC, 8 ViewModels, 20 Services, 27 Views

## Constitution Check

| Gate | Status | Notes |
|------|--------|-------|
| Memory: <150 MB idle, <300 MB peak | Must verify | Currently no low-memory handler exists at all |
| CPU: <16ms view body eval | Must verify | LibraryView disk sync may violate on first load |
| Data integrity: `uniquingKeysWith` only | OK | Already enforced per constitution |
| Observer lifecycle: setup/cleanup paired | VIOLATION | LibraryView uses `[self]` (strong capture) in observers; several VMs lack `deinit` |
| Testing: regression tests for fixes | Must add | Current test coverage is minimal (3 test files) |
| Singletons via computed property | Must verify | Need audit of all View singleton access patterns |

## Project Structure

### Documentation (this feature)

```text
specs/001-app-stability/
├── spec.md              # Feature specification
├── plan.md              # This file
├── checklists/
│   └── requirements.md  # Spec quality checklist
└── tasks.md             # Task list (generated by /speckit.tasks)
```

### Source Code (files to modify)

```text
PodcastAnalyzer/
├── PodcastAnalyzerApp.swift                    # Phase 1: deferred init, low-memory handler
├── ContentView.swift                           # Phase 2: navigation delay cleanup
│
├── ViewModels/
│   ├── LibraryViewModel.swift                  # Phase 1: deinit, Phase 2: background disk sync
│   ├── EpisodeDetailViewModel.swift            # Phase 1: audit retain cycles (has deinit ✅)
│   ├── ExpandedPlayerViewModel.swift           # Phase 1: add deinit
│   ├── EpisodeListViewModel.swift              # Phase 1: add deinit
│   ├── HomeViewModel.swift                     # Phase 1: add deinit
│   ├── PodcastSearchViewModel.swift            # Phase 1: add deinit
│   ├── SettingsViewModel.swift                 # Phase 1: audit lifecycle
│   └── TranscriptGenerationViewModel.swift     # Phase 1: audit lifecycle
│
├── Views/
│   ├── LibraryView.swift                       # Phase 1: fix [self] → [weak self] retain cycle
│   ├── MiniPlayerBar.swift                     # Phase 2: move SwiftData fetch to VM
│   ├── EpisodeDetailView.swift                 # Phase 1: verify cleanup
│   ├── ExpandedPlayerView.swift                # Phase 1: verify cleanup
│   ├── EpisodeListView.swift                   # Phase 1: verify cleanup
│   ├── HomeView.swift                          # Phase 1: verify cleanup
│   └── SearchView.swift                        # Phase 2: asyncAfter audit
│
├── Services/
│   ├── EnhancedAudioManager.swift              # Phase 2: resume error handling, low-memory cache clear
│   ├── DownloadManager.swift                   # Phase 2: error recovery, disk-space check
│   ├── BackgroundSyncManager.swift             # Phase 2: memory-bounded sync
│   ├── RSSCacheService.swift                   # Phase 1: add cache bounds
│   └── PodcastRssService.swift                 # Phase 2: malformed feed isolation
│
├── Utilities/
│   └── CachedAsyncImage.swift                  # Phase 1: verify limits (already good ✅)
│
├── Services/
│   └── CrashReportingService.swift             # Phase 3: NEW — MetricKit integration
│
└── PodcastAnalyzerTests/
    ├── RetainCycleTests.swift                  # Phase 3: NEW — leak detection
    ├── ErrorHandlingTests.swift                # Phase 3: NEW — error recovery tests
    ├── ViewModelLifecycleTests.swift           # Phase 3: NEW — cleanup verification
    └── StabilityStressUITests/                 # Phase 3: NEW — UI stress tests
        └── StressTestSuite.swift
```

---

## Phase 1: Quick Wins — Retain Cycles, Lifecycle Safety, Cache Bounds

**Goal**: Eliminate known memory leaks and resource leaks with minimal risk. Each fix is isolated and independently verifiable.

**Targets**: FR-002, FR-003, FR-004, FR-013 → SC-003, SC-006

### 1.1 Fix LibraryView Retain Cycle (HIGH PRIORITY)

**File**: `PodcastAnalyzer/Views/LibraryView.swift` lines 202, 217
**Problem**: NotificationCenter observers capture `[self]` (strong), creating a retain cycle. LibraryView holds the observer → observer holds LibraryView → never deallocated.
**Fix**:
```swift
// BEFORE (line 202):
) { [self] _ in

// AFTER:
) { [weak self] _ in
    guard let self else { return }
```
Apply same fix at line 217.

**Validation**: Build → run → navigate away from Library tab → check Instruments Allocations for LibraryView deallocation.

### 1.2 Add `deinit` to All ViewModels with `cleanup()`

**Files**: All VMs that have `cleanup()` but no `deinit`:
- `LibraryViewModel.swift` — has `cleanup()` at line 158, NO deinit
- `ExpandedPlayerViewModel.swift` — has `cleanup()` at line 613, NO deinit
- `EpisodeListViewModel.swift` — has `cleanup()` at line 382, NO deinit
- `HomeViewModel.swift` — has `cleanup()` at line 412, NO deinit
- `PodcastSearchViewModel.swift` — has `cleanup()` at line 84, NO deinit

**Fix**: Add to each:
```swift
deinit {
    cleanup()
}
```
`EpisodeDetailViewModel.swift` already has `deinit` at line 2269 — verify it calls `cleanup()`.

**Why**: `onDisappear` is not guaranteed to fire (e.g., parent view removed from hierarchy). `deinit` is the last-resort safety net.

**Validation**: Build → run → navigate repeatedly → Instruments Allocations shows no leaked ViewModel instances.

### 1.3 Audit ShortcutsAIService Strong Self Capture

**File**: `PodcastAnalyzer/Services/ShortcutsAIService.swift` line 59
**Problem**: Uses `[self]` in a Task closure. Since this is an actor, self is implicitly strongly captured anyway, but verify this doesn't create a cycle if the actor holds a reference back.
**Fix**: If the actor is a singleton (`.shared`), this is safe. If not, change to `[weak self]`. Read the file to determine.

### 1.4 Verify RSSCacheService Has Bounded Storage

**File**: `PodcastAnalyzer/Services/RSSCacheService.swift`
**Problem**: Unknown if cache has size/count limits per constitution requirement.
**Fix**: If unbounded, add `countLimit` and/or eviction policy. Use `NSCache` with `countLimit` or a manual LRU with a cap (e.g., 50 cached feeds).

### 1.5 Audit All Singleton Access from Views

**Constitution rule**: Singletons accessed from Views must use computed properties (`var x: T { .shared }`), not `@State`.
**Action**: Grep for `@State.*shared` or `@StateObject.*shared` patterns in Views. Fix any violations to use computed property pattern.

---

## Phase 2: Deeper Refactoring — Off-Main Work, Error Handling, Low-Memory

**Goal**: Move blocking work off the main thread, add error isolation, handle low-memory warnings, harden background/foreground transitions.

**Targets**: FR-001, FR-005, FR-006, FR-007, FR-008 → SC-001, SC-005, SC-007, SC-008

### 2.1 Move LibraryViewModel Disk Sync Off Critical Path

**File**: `PodcastAnalyzer/ViewModels/LibraryViewModel.swift` lines 597-704
**Problem**: `syncDownloadedFilesWithSwiftData()` runs nested loops over all podcasts/episodes checking disk. This runs on first load and can block for 2-5 seconds with large libraries.
**Current mitigation**: Runs only once per session (`hasSyncedDownloads` guard). But first run still blocks.
**Fix**:
1. Split into two stages: (a) quick SwiftData fetch of download records (fast, stays on MainActor for SwiftData access), (b) disk I/O verification dispatched to `Task.detached(priority: .background)`.
2. Update UI after background stage completes via `@MainActor` callback.
3. Show cached/stale data immediately while sync runs in background.

**Validation**: Launch with 50+ podcasts → Library tab appears instantly → disk sync completes in background without UI stutter.

### 2.2 Move MiniPlayerBar SwiftData Fetch to Async

**File**: `PodcastAnalyzer/Views/MiniPlayerBar.swift` lines 173-228
**Problem**: `findEpisodeToPlay()` runs two SwiftData fetches and a nested loop on the main thread inside a View.
**Fix**: Make `findEpisodeToPlay()` async. Wrap the call site in `Task { @MainActor in ... }`. Consider moving to a lightweight ViewModel or extension method that caches the result.

**Validation**: Tap play with no current episode → no main-thread hang measurable in Instruments.

### 2.3 Add Low-Memory Warning Handler

**File**: `PodcastAnalyzer/PodcastAnalyzerApp.swift` (add observer in `onAppear`)
**Problem**: No low-memory handler exists anywhere in the codebase.
**Fix**:
```swift
// In PodcastAnalyzerApp or a dedicated coordinator:
NotificationCenter.default.addObserver(
    forName: UIApplication.didReceiveMemoryWarningNotification, // iOS
    ...
) { _ in
    // 1. Clear CachedAsyncImage's NSCache
    ImageCacheManager.shared.clearAll()
    // 2. Clear RSSCacheService
    RSSCacheService.shared.clearCache()
    // 3. Log the event
    logger.warning("Low memory warning: caches cleared")
}
```
On macOS, use `NSApplication` equivalent or a Combine publisher on process memory pressure.

**Validation**: Simulate memory warning in Simulator (Debug → Simulate Memory Warning) → verify caches clear and app continues.

### 2.4 Deferred Singleton Initialization at Launch

**File**: `PodcastAnalyzerApp.swift` lines 66-87
**Problem**: Multiple singletons initialized in `onAppear` on MainActor. Adds 50-200ms to first-frame time.
**Fix**:
1. Keep only essential inits (PlaybackStateCoordinator, BackgroundSyncManager) synchronous.
2. Defer non-critical inits (PodcastImportManager, NotificationNavigationManager) to `Task.detached` after first frame.
3. Use `task` modifier instead of `onAppear` for async setup.

### 2.5 Harden RSS Feed Parsing Error Isolation

**File**: `PodcastAnalyzer/Services/PodcastRssService.swift`
**Problem**: Need to verify that a malformed feed doesn't crash the entire sync operation.
**Fix**: Ensure each feed parse is wrapped in its own `do/catch` block. On failure, log the error and mark that feed as errored — don't propagate the error to cancel sibling feeds.

**Validation**: Feed a known-bad XML string → only that feed shows error → other feeds load normally.

### 2.6 DownloadManager Error Recovery & Disk Space Check

**File**: `PodcastAnalyzer/Services/DownloadManager.swift`
**Fixes**:
1. Before starting a download, check available disk space. If <50 MB, set state to `.failed(error: .insufficientStorage)` and surface a user message.
2. On network failure mid-download, set state to `.failed` with retry capability instead of silently stalling.
3. Handle the edge case where a download record points to a missing file — reset to `.notDownloaded`.

### 2.7 EnhancedAudioManager Interruption Resume Hardening

**File**: `PodcastAnalyzer/Services/EnhancedAudioManager.swift` line 246
**Problem**: 0.8s delay for audio resume after interruption has no error handling if resume fails.
**Fix**: After `self.resume()`, check player status. If not playing after a brief check, retry once. Log the outcome either way.

### 2.8 Background/Foreground State Restoration

**File**: `PodcastAnalyzer/PodcastAnalyzerApp.swift` + `ContentView.swift`
**Problem**: Verify that backgrounding for extended periods preserves tab selection, playback position, scroll position.
**Fix**:
1. Tab selection is likely already preserved via `@State`/`@SceneStorage`. Verify.
2. Playback position: `EnhancedAudioManager` already saves to UserDefaults — verify it restores on foreground.
3. Add `scenePhase` observer if not present to trigger save on `.background` transition.

---

## Phase 3: Observability, Testing, and Stress Validation

**Goal**: Add crash reporting, build automated test suite proving stability, establish ongoing regression protection.

**Targets**: FR-010, SC-004, SC-006, SC-009

### 3.1 Integrate MetricKit for Crash Analytics

**New file**: `PodcastAnalyzer/Services/CrashReportingService.swift`
**Approach**: Use Apple's built-in `MetricKit` framework (no third-party SDK). This captures:
- Hang reports (MXHangDiagnostic)
- Crash reports (MXCrashDiagnostic)
- Disk write diagnostics
- CPU/memory metrics

```swift
import MetricKit

final class CrashReportingService: NSObject, MXMetricManagerSubscriber {
    static let shared = CrashReportingService()

    func start() {
        MXMetricManager.shared.add(self)
    }

    func didReceive(_ payloads: [MXMetricPayload]) {
        // Process daily metric payloads
    }

    func didReceive(_ payloads: [MXDiagnosticPayload]) {
        // Process crash/hang diagnostics
        // Log to os.Logger for on-device review
    }
}
```

Call `CrashReportingService.shared.start()` from `PodcastAnalyzerApp.onAppear`.

**Platform**: MetricKit is iOS 13+ / macOS 12+. Use `#if os(iOS)` guard since macOS support is more limited. On macOS, rely on built-in crash reporter.

### 3.2 Add os_signpost for Performance Instrumentation

**Files**: Key ViewModels and Services
**Approach**: Add `os_signpost` intervals around critical operations for Instruments profiling:
- `LibraryViewModel.loadAll()` — data load time
- `PodcastRssService.fetchFeed()` — network + parse time
- `syncDownloadedFilesWithSwiftData()` — disk sync time
- View body evaluations (via `_printChanges()` in debug only)

Keep signpost code behind `#if DEBUG` to avoid production overhead.

### 3.3 Retain Cycle Detection Tests

**New file**: `PodcastAnalyzerTests/RetainCycleTests.swift`
**Approach**: For each ViewModel, test that it deallocates when its reference is set to nil:
```swift
func testLibraryViewModelDeallocates() {
    var vm: LibraryViewModel? = LibraryViewModel(modelContext: testContext)
    weak var weakVM = vm
    vm?.cleanup()
    vm = nil
    XCTAssertNil(weakVM, "LibraryViewModel leaked — retain cycle detected")
}
```
Write one test per ViewModel. This directly validates SC-006.

### 3.4 ViewModel Lifecycle Tests

**New file**: `PodcastAnalyzerTests/ViewModelLifecycleTests.swift`
**Approach**: Test that after `cleanup()`:
- Timers are invalidated (no more callbacks fire)
- Observers are removed (notification doesn't trigger handler)
- Tasks are cancelled

```swift
func testLibraryViewModelCleanupStopsTimer() {
    let vm = LibraryViewModel(modelContext: testContext)
    vm.cleanup()
    // Fire notification — should NOT update state
    NotificationCenter.default.post(name: .podcastSyncCompleted, object: nil)
    // Assert state didn't change
}
```

### 3.5 Error Handling Tests

**New file**: `PodcastAnalyzerTests/ErrorHandlingTests.swift`
**Approach**: Test that error conditions don't crash:
- Malformed RSS XML → parse returns error, not crash
- Missing audio file on disk → state resets to `.notDownloaded`
- Corrupted SwiftData store → graceful reset
- Network timeout → appropriate error state

### 3.6 UI Stress Test Suite

**New file**: `PodcastAnalyzerUITests/StressTestSuite.swift`
**Approach**: XCUITest that:
1. Launches app
2. Rapidly cycles through all tabs (100+ iterations)
3. Opens and closes episode detail views (50+ times)
4. Triggers play/pause rapidly
5. Navigates to library, scrolls to bottom, back to top
6. Runs for up to 60 minutes in CI (shortened iterations for local dev)

**Assertions**:
- App never crashes (implicit — test runner would fail)
- Memory at end is within 20% of start (read via `XCUIApplication` performance metrics or external script)

### 3.7 Validate All Success Criteria

| SC | How to Verify | Phase |
|----|---------------|-------|
| SC-001 | Instruments Time Profiler: measure tap-to-render | Phase 2 validation |
| SC-002 | Instruments Core Animation FPS during scroll stress test | Phase 2 validation |
| SC-003 | Instruments Allocations: compare 5-min vs 60-min baseline | Phase 3 stress test |
| SC-004 | StressTestSuite passes with zero crashes | Phase 3 |
| SC-005 | Instruments Thread State: no main-thread block >16ms | Phase 2 validation |
| SC-006 | RetainCycleTests all pass | Phase 3 |
| SC-007 | ErrorHandlingTests all pass | Phase 3 |
| SC-008 | Manual test: background 5 min → foreground → state intact | Phase 2 validation |
| SC-009 | CrashReportingService receives MXDiagnosticPayload in test | Phase 3 |

---

## Key Swift Patterns & Tools

### Concurrency Model
- **Prefer `async/await`** over GCD `DispatchQueue` for new code
- **`@MainActor`** on all ViewModel classes and UI-updating closures
- **`Task.detached(priority: .background)`** for heavy disk/compute work
- **Actors** already used for `PodcastRssService`, `FileStorageManager` — keep this pattern
- **`Task` cancellation**: Store `Task` handles as properties, cancel in `cleanup()`/`deinit`

### Memory Management
- **`[weak self]`** in ALL closures passed to NotificationCenter, Timer, DispatchQueue
- **`deinit`** on every ViewModel as safety net for `cleanup()`
- **`NSCache` with limits** for all caches (already done for images — add for RSS)
- **`onDisappear` + `onAppear`** paired for all view-scoped resources

### Error Handling
- **`do/catch` per-item** in batch operations (don't let one bad feed kill the sync)
- **Result type** or error state in ViewModels for user-facing error display
- **Never force-unwrap** network responses or file reads

### Logging & Diagnostics
- **`os.Logger`** already used widely — continue this pattern
- **`os_signpost`** for performance-critical intervals (debug builds)
- **`MetricKit`** for production crash/hang reporting (iOS)

---

## Platform Differences (iOS vs macOS)

Minimal differences for this feature:

| Concern | iOS | macOS |
|---------|-----|-------|
| Low-memory warning | `UIApplication.didReceiveMemoryWarningNotification` | No direct equivalent; use `ProcessInfo.processInfo.isLowPowerModeEnabled` or skip |
| MetricKit | Full support (iOS 13+) | Limited (`MXMetricManager` available macOS 12+ but no hang diagnostics) |
| Device rotation | Must handle on iPad | N/A (window resizing handled by SwiftUI) |
| Background downloads | `URLSession` background config | Same API, always foreground |
| Crash reporting | MetricKit + on-device | MetricKit (limited) + Apple crash reporter |

**Implementation**: Use `#if os(iOS)` for UIApplication-specific APIs. Use `#if os(macOS)` for NSApplication equivalents where needed. Most stability fixes (retain cycles, deinit, error handling) are platform-agnostic.

---

## Riskiest Parts & Early Validation Strategy

| Risk | What Could Go Wrong | Validate Early By |
|------|---------------------|-------------------|
| LibraryViewModel background disk sync | Moving work off MainActor may break SwiftData context access (SwiftData contexts are not thread-safe) | Create a background `ModelContext` from the same `ModelContainer` for the disk sync. Test with 50+ podcasts. |
| deinit calling cleanup() | If cleanup() accesses `@Published` properties during deallocation, may crash | Write unit test that creates and immediately nils each ViewModel. Run under Address Sanitizer. |
| Low-memory cache clearing | Clearing image cache while views are displaying could cause flicker | Clear only the `NSCache` (not displayed images) — SwiftUI will re-request from cache miss. Test with Simulator memory warning. |
| MetricKit integration | MetricKit delivers payloads on a 24-hour delay — hard to test interactively | Write a test that subscribes and verifies the subscriber is registered. Real validation in TestFlight builds. |
| Changing observer capture semantics | Switching `[self]` to `[weak self]` in LibraryView could change behavior if self is nil when notification fires | Verify the guard-let pattern handles nil safely. The notification should simply be ignored if the view is gone. |

---

## Dependencies

**No new third-party dependencies.** All tools are built-in:

| Tool | Purpose | Already in project? |
|------|---------|-------------------|
| `os.Logger` | Structured logging | Yes ✅ |
| `os_signpost` | Performance instrumentation | No — add (Apple framework, zero-cost) |
| `MetricKit` | Crash/hang analytics | No — add (Apple framework, zero-cost) |
| `XCTest` | Unit + UI tests | Yes ✅ |
| `NSCache` | Bounded caching | Yes ✅ (CachedAsyncImage) |

---

## Execution Order Summary

```
Phase 1 (Quick Wins — Low Risk, High Impact)
├── 1.1  Fix LibraryView [self] → [weak self]           ← biggest known leak
├── 1.2  Add deinit to all ViewModels                    ← safety net
├── 1.3  Audit ShortcutsAIService [self]                 ← verify safe
├── 1.4  Verify/add RSSCacheService bounds               ← cache hygiene
└── 1.5  Audit singleton access from Views               ← constitution compliance

Phase 2 (Deeper Fixes — Medium Risk, High Impact)
├── 2.1  Background disk sync in LibraryViewModel        ← biggest responsiveness win
├── 2.2  Async MiniPlayerBar fetch                       ← main-thread cleanup
├── 2.3  Low-memory warning handler                      ← new capability
├── 2.4  Deferred launch init                            ← faster startup
├── 2.5  RSS error isolation                             ← error resilience
├── 2.6  DownloadManager error + disk check              ← error resilience
├── 2.7  Audio resume hardening                          ← playback reliability
└── 2.8  Background/foreground state restoration         ← state preservation

Phase 3 (Observability + Tests — Low Risk, Long-term Value)
├── 3.1  MetricKit CrashReportingService                 ← production visibility
├── 3.2  os_signpost instrumentation                     ← profiling support
├── 3.3  Retain cycle detection tests                    ← SC-006
├── 3.4  ViewModel lifecycle tests                       ← regression guard
├── 3.5  Error handling tests                            ← SC-007
├── 3.6  UI stress test suite                            ← SC-004
└── 3.7  Validate all success criteria                   ← final gate
```

**Build and test after every individual step.** Each step should compile and pass existing tests before moving to the next.
